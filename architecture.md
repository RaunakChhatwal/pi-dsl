# Architecture Documentation

This document outlines the architecture of the `pi-dsl` project, a Haskell-based Dependently Typed Lambda Calculus (Pi-calculus) DSL with Python bindings and tracing capabilities.

## Overview

The project is designed to implement a core dependently typed language in Haskell for correctness and performance, while exposing this functionality to Python for ease of use, scripting, and analysis (specifically tracing the type-checking process).

The system consists of three main layers:
1.  **Haskell Core**: The DSL implementation (AST, Type Checker, Evaluator).
2.  **FFI / Export Layer**: Generates C-compatible interfaces for Haskell types and functions.
3.  **Python Bindings**: Wraps the shared library to provide a native Python API for constructing terms and running type checks.

## Component Breakdown

### 1. Haskell Core (`src/`)

The core logic resides in the `src/` directory.

*   **Syntax (`src/Syntax.hs`)**: Defines the Abstract Syntax Tree (AST) for the language.
    *   Supports dependent types (`Pi`), abstractions (`Lam`), applications (`App`), and Variables (`Var`).
    *   Includes primitives for recursive data types: `DataType`, `Ctor`, and `Rec`.
    *   Uses `unbound-generics` for variable binding and substitution (Locally Nameless representation).
*   **Type Checker (`src/TypeCheck.hs`)**: Implements bidirectional type checking.
    *   `inferType`: Infers the type of a term.
    *   `checkType`: Checks if a term matches a given type.
    *   Delegates data type logic to `src/Inductive.hs`.
*   **Inductive Logic (`src/Inductive.hs`)**: Handles inductive data types.
    *   Validates data type declarations (strict positivity checks).
    *   Synthesizes types for recursors (dependent elimination).
    *   Implements `reduceRecursor` for iota reduction (recursor unfolding).
*   **Equality & Evaluation (`src/Equal.hs`)**:
    *   `equate`: Checks if two terms are definitionally equal.
    *   `whnf`: Reduces terms to Weak Head Normal Form (handling Beta and Iota reductions).
*   **Environment (`src/Environment.hs`)**: Manages the type-checking context (variable mappings, data type definitions) and the `TcMonad` (Type Checking Monad) which handles errors and tracing.
*   **Bindings (`src/Bindings.hs`)**: A utility module (likely using Template Haskell) to generate `Foreign.Storable` instances for Haskell ADTs, enabling them to be passed to C.

### 2. Export Layer (`export/`)

This layer bridges Haskell and C/Python.

*   **`export/Export.hs`**: The main entry point for the shared library.
    *   Exports functions like `type_check`, `infer_type`, and `trace_type_check` via `foreign export`.
    *   Uses Template Haskell to automatically derive `Storable` instances for `Term`, `Entry`, `Trace`, etc., ensuring the memory layout matches what the Python side expects.
*   **Build System**: The project builds a shared object (`.so`) file (e.g., `pi-forall-lib.so`) using Cabal/Nix.

### 3. Python Bindings (`pi_dsl/`)

These files provide a Pythonic interface to the compiled Haskell library using `ctypes`.

*   **Base (`pi_dsl/base.py`)**:
    *   Locates and loads the compiled shared library.
    *   Defines generic structures for C-interop: `TaggedUnion` (for ADTs), `List`, `Tuple`.
    *   Initializes the Haskell runtime (`pi_forall_init`).
*   **Term & Bindings (`pi_dsl/term.py`, `pi_dsl/bindings.py`)**:
    *   Define Python classes that mirror the Haskell data types (e.g., `Term` class has `init_lam`, `init_app` methods corresponding to Haskell constructors).
    *   The memory layout of these classes is carefully aligned to match the C structs generated by the Haskell `Storable` instances.
    *   Exposes high-level functions: `type_check(entries)`, `infer_type(entries, term)`.
*   **Tracing (`pi_dsl/tracing.py`)**:
    *   `TraceTree`: A Python class that reconstructs the hierarchical call stack from the flat list of trace events returned by Haskell.
    *   Allows visualization of the type-checking steps.

## Interoperability (FFI)

The communication happens via direct memory mapping of Algebraic Data Types (ADTs).

1.  **Data Layout**: Haskell ADTs are treated as "Tagged Unions" (a tag indicating the constructor, followed by the payload).
    *   Python's `TaggedUnion` in `base.py`` maps to this layout.
2.  **Function Calls**:
    *   Python calls C-exported functions from the Haskell library.
    *   Arguments are pointers to constructed Python objects (which mimic the Haskell heap layout).
    *   Results are returned as pointers to structs, which Python reads back.

## Tracing

A key feature is `trace_type_check`.
*   As the Haskell type checker runs, it emits trace events (`Invoc` for function entry, `Event` for steps, `Result` for successes).
*   These are collected in the `TcMonad`.
*   The `trace_type_check` function returns these traces to Python.
*   The Python side receives a list of `Trace` objects, allowing visualization or debugging of the type-checking algorithm.

## Directory Structure

```
├── app/                # Main Haskell executable (CLI)
├── export/             # FFI Export definitions
│   └── Export.hs       # Exports functions to C
├── pi_dsl/             # Python package
│   ├── base.py         # ctypes loading & primitives
│   ├── bindings.py     # General ADT bindings (Maybe, Either, Trace)
│   ├── term.py         # DSL AST bindings (Term, Entry)
│   └── tracing.py      # Trace processing and visualization
├── src/                # Haskell Core
│   ├── Syntax.hs       # AST
│   ├── TypeCheck.hs    # Type Checker logic
│   ├── Inductive.hs    # Data types and Recursors
│   ├── Equal.hs        # Equality and Normalization
│   └── Bindings.hs     # TH for FFI generation
└── test/               # Python tests/examples
```
